
---

### **技术方案设计说明书 (TSD) - 项目代号：Aurora**

**版本：** 1.0
**日期：** 2025年9月29日

#### **1. 系统架构**

本系统采用**模块化的事件驱动架构**。系统的核心是一个事件循环，它从数据源（历史CSV文件或实时WebSocket流）获取市场事件（如新的K线），并将这些事件分发给策略模块。策略模块处理事件后，产生交易信号，信号再由执行模块处理，最终更新投资组合的状态。

**1.1. Cargo Workspace 结构与依赖关系**

*   **`aurora-core`**: (库) 无外部项目依赖。定义了所有其他crate共享的基础数据结构和核心Trait。
*   **`aurora-data`**: (二进制) 依赖 `aurora-core`, `tokio`, `reqwest`, `tokio-tungstenite`, `serde`, `serde_json`, `csv`, `clap`, `tracing`。负责所有外部数据交互。
*   **`aurora-indicators`**: (库) 依赖 `aurora-core`。提供纯计算的技术指标。
*   **`aurora-strategy`**: (库) 依赖 `aurora-core`, `aurora-indicators`。实现具体的交易策略逻辑。
*   **`aurora-backtester`**: (二进制) 依赖 `aurora-core`, `aurora-strategy`, `csv`, `clap`, `tracing`。实现离线回测功能。
*   **`aurora-live`**: (二进制) 依赖 `aurora-core`, `aurora-strategy`, `tokio`, `tokio-tungstenite`, `tracing`, `clap`。实现实时模拟交易功能。

**1.2. 核心设计模式**

*   **策略模式 (Strategy Pattern):** 通过定义`Strategy` trait，将算法（交易策略）的定义与其使用方（回测引擎/实时引擎）解耦。
*   **依赖注入 (Dependency Injection):** 引擎（回测/实时）在创建时，会将具体的数据源和策略实例作为依赖注入，而不是在内部创建它们。这增强了系统的可测试性和灵活性。

---

#### **2. `aurora-core`: 核心抽象与数据结构**

**文件: `aurora-core/src/lib.rs`**

**2.1. `MarketEvent` 枚举**

为了统一处理不同类型的市场数据，我们定义一个事件枚举。

```rust
use serde::{Deserialize, Serialize};

// 核心数据结构：K线
#[derive(Debug, Clone, PartialEq, Deserialize, Serialize)]
pub struct Kline {
    pub timestamp: i64, // Unix Millisecond Timestamp
    pub open: f64,
    pub high: f64,
    pub low: f64,
    pub close: f64,
    pub volume: f64,
}

// 市场事件枚举，统一数据源的输出
#[derive(Debug, Clone)]
pub enum MarketEvent {
    Kline(Kline),
    // 未来可扩展，如逐笔成交 Trade, 订单簿 OrderBook 等
}

// 交易信号枚举
#[derive(Debug, Clone, PartialEq)]
pub enum Signal {
    Buy,
    Sell,
    Hold,
}

// 包含信号和一些元数据，如触发价格
#[derive(Debug, Clone)]
pub struct SignalEvent {
    pub signal: Signal,
    pub price: f64,
    pub timestamp: i64,
}
```

**2.2. `DataSource` Trait**

定义一个异步数据源的统一接口，使得回测和实时引擎可以透明地切换数据来源。

```rust
use async_trait::async_trait;
use tokio::sync::mpsc::UnboundedReceiver;

// 定义异步trait需要 `async_trait` 库
#[async_trait]
pub trait DataSource {
    // 返回一个无界通道的接收端，用于接收市场事件
    async fn start(&mut self) -> anyhow::Result<UnboundedReceiver<MarketEvent>>;
}
```

**2.3. `Strategy` Trait**

定义策略模块的统一接口。

```rust
pub trait Strategy: Send + Sync {
    // 每次市场事件发生时调用
    fn on_market_event(&mut self, event: &MarketEvent) -> Option<SignalEvent>;
}
```
*   `Send + Sync` 约束是必要的，以便策略实例可以在多线程环境中安全地传递。

---

#### **3. `aurora-data`: 数据采集实现**

**3.1. `HistoricalDataSource` (用于回测)**

这是一个读取CSV文件的数据源实现。

```rust
// In aurora-data/src/historical.rs
use aurora_core::{DataSource, MarketEvent, Kline};
use tokio::sync::mpsc::{self, UnboundedReceiver, UnboundedSender};
use async_trait::async_trait;

pub struct HistoricalDataSource {
    file_path: String,
}

impl HistoricalDataSource {
    pub fn new(file_path: &str) -> Self {
        Self { file_path: file_path.to_string() }
    }
}

#[async_trait]
impl DataSource for HistoricalDataSource {
    async fn start(&mut self) -> anyhow::Result<UnboundedReceiver<MarketEvent>> {
        let (tx, rx) = mpsc::unbounded_channel();
        let path = self.file_path.clone();

        // 启动一个新任务来读取文件并发送数据
        tokio::spawn(async move {
            let mut rdr = csv::Reader::from_path(path).unwrap();
            for result in rdr.deserialize::<Kline>() {
                match result {
                    Ok(kline) => {
                        if let Err(e) = tx.send(MarketEvent::Kline(kline)) {
                            tracing::error!("Failed to send kline: {}", e);
                            break;
                        }
                    }
                    Err(e) => tracing::error!("CSV parsing error: {}", e),
                }
            }
        });

        Ok(rx)
    }
}
```

**3.2. `LiveDataSource` (用于实时交易)**

这是一个连接WebSocket的数据源实现。

```rust
// In aurora-data/src/live.rs
// ... imports ...
use tokio_tungstenite::connect_async;
use futures_util::StreamExt;

pub struct LiveDataSource {
    // e.g., "wss://stream.binance.com:9443/ws/btcusdt@kline_1m"
    stream_url: String, 
}

// ... new() ...

#[async_trait]
impl DataSource for LiveDataSource {
    async fn start(&mut self) -> anyhow::Result<UnboundedReceiver<MarketEvent>> {
        let (tx, rx) = mpsc::unbounded_channel();
        let url = self.stream_url.clone();

        tokio::spawn(async move {
            loop { // Auto-reconnect loop
                let (ws_stream, _) = connect_async(&url).await.expect("Failed to connect");
                let (_, mut read) = ws_stream.split();

                while let Some(message) = read.next().await {
                    match message {
                        Ok(msg) => {
                            // Parse message, e.g., using serde_json
                            // ... parse logic to get Kline ...
                            // let kline = ...;
                            // tx.send(MarketEvent::Kline(kline)).unwrap();
                        },
                        Err(e) => {
                            tracing::error!("WebSocket error: {}", e);
                            break; // Break inner loop to reconnect
                        }
                    }
                }
                tracing::info!("Reconnecting WebSocket...");
                tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
            }
        });

        Ok(rx)
    }
}
```

---

#### **4. `aurora-backtester`: 回测引擎设计**

**文件: `aurora-backtester/src/main.rs` 及相关模块**

**4.1. `Portfolio` 模块**

负责状态管理的核心组件。

```rust
// In aurora-backtester/src/portfolio.rs
pub struct Portfolio {
    pub cash: f64,
    pub position: f64,
    pub initial_equity: f64,
    // ... other metrics like equity curve, trades list ...
}

impl Portfolio {
    // Methods to update state based on trades
    pub fn execute_buy(&mut self, price: f64, amount: f64) { /* ... */ }
    pub fn execute_sell(&mut self, price: f64, amount: f64) { /* ... */ }
    pub fn get_total_equity(&self, current_price: f64) -> f64 { /* ... */ }
}
```

**4.2. `Backtester` 引擎主流程**

```rust
// In aurora-backtester/src/engine.rs
use aurora_core::{DataSource, Strategy, Signal};

pub struct Backtester {
    data_source: Box<dyn DataSource>,
    strategy: Box<dyn Strategy>,
    portfolio: Portfolio,
}

impl Backtester {
    pub async fn run(&mut self) -> anyhow::Result<()> {
        let mut event_receiver = self.data_source.start().await?;

        while let Some(event) = event_receiver.recv().await {
            // 1. Update strategy and get signal
            if let Some(signal_event) = self.strategy.on_market_event(&event) {
                // 2. Execute signal
                match signal_event.signal {
                    Signal::Buy => {
                        // For simplicity, buy 1 unit
                        self.portfolio.execute_buy(signal_event.price, 1.0); 
                    },
                    Signal::Sell => {
                        // Sell all position
                        self.portfolio.execute_sell(signal_event.price, self.portfolio.position);
                    },
                    Signal::Hold => {}
                }
            }
            
            // 3. Update portfolio equity based on current market price
            // ...
        }

        // 4. Generate and print report
        self.print_report();
        Ok(())
    }
    
    fn print_report(&self) { /* ... */ }
}
```

---

#### **5. `aurora-live`: 实时引擎设计**

**文件: `aurora-live/src/main.rs` 及相关模块**

**5.1. `LiveEngine` 设计**

`LiveEngine`的结构与`Backtester`高度相似，体现了架构的复用性。主要区别在于`Portfolio`的管理和执行逻辑。

```rust
// In aurora-live/src/engine.rs
// ... similar imports ...

pub struct LiveEngine {
    data_source: Box<dyn DataSource>,
    strategy: Box<dyn Strategy>,
    // The portfolio is now a "paper trading" portfolio
    paper_portfolio: Portfolio, 
}

impl LiveEngine {
    pub async fn run(&mut self) -> anyhow::Result<()> {
        let mut event_receiver = self.data_source.start().await?;

        while let Some(event) = event_receiver.recv().await {
            if let Some(signal_event) = self.strategy.on_market_event(&event) {
                // Instead of executing, we log and notify
                self.process_paper_trade(signal_event);
            }

            // Periodically log portfolio status
            // ...
        }
        Ok(())
    }

    fn process_paper_trade(&mut self, signal_event: SignalEvent) {
        tracing::info!("PAPER TRADE SIGNAL: {:?}", signal_event);
        // Update paper_portfolio state
        // ...
        // Optionally, send a notification via a webhook or bot
    }
}
```

---

#### **6. 错误处理与日志**

*   **错误处理：** 所有可能失败的函数（特别是IO操作）应返回`anyhow::Result<T>`。这提供了一种统一且带有上下文的错误处理方式。
*   **日志：**
    *   使用`tracing`库进行结构化日志记录。
    *   在`main`函数中初始化`tracing_subscriber`，并允许通过环境变量`RUST_LOG`（例如 `RUST_LOG=aurora_backtester=info,aurora_core=debug`）来控制日志级别。
    *   关键事件（如交易信号、错误、连接状态）必须记录日志。

---

#### **7. 测试策略**

*   **单元测试：**
    *   `aurora-indicators`: 对每个指标的计算逻辑进行严格的单元测试。
    *   `aurora-strategy`: 对每个策略的状态转换和信号生成进行单元测试。
    *   `aurora-core`: 对数据结构的序列化/反序列化进行测试。
*   **集成测试：**
    *   在`aurora-backtester`中，创建一个小型的、固定的CSV测试文件和一个简单的策略。运行完整的回测流程，并断言最终的投资组合状态和报告指标是否符合预期。
    *   在`aurora-data`中，编写测试来验证与真实交易所API（可以使用mock服务器或沙盒环境）的连接和数据解析。

---

这份技术设计方案提供了实现"Aurora"项目的详细蓝图。下一步就是根据这份设计，开始逐个模块、逐个功能地编写代码。在开发过程中，这份文档也可以作为代码审查（Code Review）的依据。