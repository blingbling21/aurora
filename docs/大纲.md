
---

### **项目代号：Aurora**

**最终目标：** 构建一个模块化的事件驱动框架，它既可以用于历史数据回测，也可以无缝切换到实时数据进行模拟交易。

**核心设计哲学：**
*   **模块化/关注点分离：** 数据、策略、执行、风控等模块应相互独立，像乐高积木一样可以自由组合。
*   **性能与安全：** 充分利用Rust的优势，确保数据处理的高效和多线程环境下的内存安全。
*   **事件驱动：** 整个系统由市场数据（事件）的到来而驱动，这是一种高度可扩展的架构。

---

### **阶段零：地基与工具箱 (准备工作)**

**目标：** 搭建开发环境，确立项目结构，并熟悉核心工具。

1.  **环境搭建：**
    *   安装Rust工具链 (`rustup`)。
    *   安装VS Code，并配备`rust-analyzer`插件（这是目前最好的Rust开发体验）。

2.  **项目结构规划 (Cargo Workspace)：**
    *   我们将使用Cargo的Workspace功能，它允许在一个代码仓库中管理多个相互关联的包（crates）。
    *   在你的项目根目录创建 `Cargo.toml` 文件，内容如下：
        ```toml
        [workspace]
        members = [
            "aurora-data",      # 数据采集模块
            "aurora-core",      # 核心数据结构与trait
            "aurora-indicators",# 技术指标库
            "aurora-strategy",  # 策略逻辑
            "aurora-backtester",# 回测引擎
            "aurora-live"       # 实时模拟交易引擎
        ]
        ```
    *   然后使用 `cargo new aurora-data`，`cargo new aurora-core --lib` 等命令创建相应的目录。

3.  **核心依赖“工具箱”：**
    *   `tokio`: 异步运行时，我们所有网络操作和并发任务的基础。
    *   `serde`: 数据序列化/反序列化。用于将交易所的JSON数据转换为我们的Rust结构体。
    *   `reqwest`: 一个强大且易用的HTTP客户端，用于下载历史数据。
    *   `tokio-tungstenite`: 异步WebSocket客户端，用于接收实时数据流。
    *   `chrono`: 处理时间序列数据。
    *   `tracing`: 用于日志记录，比 `println!` 更专业、更强大。
    *   `csv`: 读写CSV文件。

---

### **阶段一：数据核心 (`aurora-core` & `aurora-data`)**

**目标：** 定义核心数据结构，并能从交易所获取历史和实时数据。

1.  **定义核心数据结构 (`aurora-core`)**
    *   在 `aurora-core/src/lib.rs` 中定义所有模块都会用到的基础类型。
    *   `Kline`: 定义一个包含开、高、低、收、成交量和时间戳的结构体。使用 `serde` 的 `#[derive(Deserialize)]` 宏，使其可以直接从JSON解析。
    *   `Trade`: 定义一个包含价格、数量和时间戳的结构体，用于接收实时的逐笔成交数据。
    *   `Signal`: 定义一个枚举 `enum Signal { Buy, Sell, Hold }`，用于策略模块向执行模块传递信号。

2.  **构建数据采集器 (`aurora-data`)**
    *   这是一个二进制包，将成为我们的“数据部门”。
    *   **功能A：历史数据下载器**
        *   使用 `clap` 库创建一个命令行接口，可以接收参数如 `--symbol BTCUSDT --interval 1h --start 2024-01-01`。
        *   使用 `reqwest` 异步请求交易所的REST API来下载历史K线数据。
        *   使用 `csv` 库将获取到的数据（解析为`Kline`结构体）保存到本地CSV文件中。
        *   **成果：** 你有了一个可以重复使用的工具，能为你准备回测所需的“弹药”。
    *   **功能B：实时数据流记录器**
        *   在命令行中增加一个 `--live` 模式。
        *   使用 `tokio-tungstenite` 连接交易所的WebSocket行情接口。
        *   订阅指定交易对的K线或逐笔成交频道。
        *   在一个异步循环中接收消息，使用 `serde_json` 解析成`Kline`或`Trade`，然后**清晰地打印在控制台**。
        *   **成果：** 你有了一个能实时监控市场脉搏的程序。

---

### **阶段二：策略大脑 (`aurora-indicators` & `aurora-strategy`)**

**目标：** 将交易思想代码化，创建可复用的技术指标和策略逻辑。

1.  **技术指标库 (`aurora-indicators`)**
    *   这是一个纯粹的计算库，不涉及任何IO操作。
    *   **实现 `MA` (移动平均线):** 创建一个 `MA` 结构体，它内部维护一个固定大小的队列（`VecDeque`）。提供一个 `update(&self, price: f64) -> f64` 方法，每当有新价格进来，它就更新并返回最新的平均值。
    *   **实现 `RSI` (相对强弱指数):** 这是一个稍微复杂但非常经典的指标。实现它会让你对状态管理有更深的理解。

2.  **策略逻辑库 (`aurora-strategy`)**
    *   **定义 `Strategy` Trait:** 这是本阶段的核心！定义一个通用的策略接口。
        ```rust
        use aurora_core::{Kline, Signal};
        
        pub trait Strategy {
            // 每当有一个新的K线数据，就调用这个方法
            fn on_kline(&mut self, kline: &Kline) -> Signal;
        }
        ```
    *   **实现第一个策略：MA交叉策略**
        *   创建一个 `MACrossover` 结构体，它内部包含两个 `MA` 实例（一个短期，一个长期）。
        *   为 `MACrossover` 实现 `Strategy` trait。在 `on_kline` 方法中：
            1.  用收盘价更新两个MA。
            2.  判断当前MA值和上一个时间点的MA值，来确定是否发生了“金叉”或“死叉”。
            3.  根据判断结果，返回 `Signal::Buy`, `Signal::Sell`, 或 `Signal::Hold`。
    *   **成果：** 你拥有了一个与数据源、与执行方式完全解耦的、可独立测试的“策略大脑”。你可以轻松地写出第二个、第三个策略。

---

### **阶段三：历史回测 (`aurora-backtester`)**

**目标：** 组装前两个阶段的成果，创建你的“金融时间机器”。

1.  **创建回测引擎 (`aurora-backtester`)**
    *   这是一个二进制包，它将依赖 `aurora-core`, `aurora-data`, `aurora-strategy`。
    *   **核心组件 `BacktestEngine`:**
        1.  **数据加载器：** 读取 `aurora-data` 生成的CSV文件，将其解析为 `Vec<Kline>`。
        2.  **模拟账户 (`Portfolio`):** 一个结构体，负责管理现金、持仓、计算总资产和盈亏。
        3.  **模拟执行器 (`Executor`):** 当收到 `Signal::Buy` 或 `Signal::Sell` 时，负责更新 `Portfolio` 的状态（模拟成交，暂不考虑手续费和滑点）。
        4.  **主循环:** 遍历所有历史 `Kline` 数据。在每次循环中：
            *   将当前的 `Kline` 喂给 `Strategy` 实例。
            *   获取返回的 `Signal`。
            *   将 `Signal` 和当前 `Kline` 的价格信息传递给 `Executor`。
            *   更新 `Portfolio` 的每日市值。
    *   **生成回测报告:**
        *   当循环结束后，计算并打印一份详细报告：总回报率、年化回报率、最大回撤、夏普比率、胜率、总交易次数等。
    *   **成果：** 你可以对你的策略进行量化评估了！你可以通过调整策略参数（如MA的周期），运行回测，直观地看到参数变化对结果的影响，这是量化研究最迷人的一步。

---

### **阶段四：上线模拟 (`aurora-live`)**

**目标：** 将回测成功的策略，部署到实时数据流中进行模拟交易，验证其在真实环境下的表现。

1.  **创建实时引擎 (`aurora-live`)**
    *   这个二进制包的结构会和 `aurora-backtester` 非常相似，体现了我们模块化设计的好处。
    *   **替换数据源：** 不再从CSV读取数据，而是使用 `aurora-data` 中的WebSocket实时数据流代码作为数据源。
    *   **复用策略逻辑：** 同样实例化一个实现了 `Strategy` trait 的策略结构体。每当WebSocket收到一个新的、完整的K线数据，就调用策略的 `on_kline` 方法。
    *   **创建模拟交易执行器 (`PaperTrader`):** 当策略发出 `Buy` 或 `Sell` 信号时，这个执行器**不会真的下单**，而是：
        1.  记录一笔模拟交易日志。
        2.  更新一个内存中的模拟账户状态。
        3.  通过Telegram Bot或Discord Webhook给自己发一条通知：“模拟买入 BTCUSDT at 72000.50”。
    *   **成果：** 你拥有了一个7x24小时运行的自动化交易机器人（模拟盘）。你可以观察它在真实、不可预测的市场波动中的表现，这是对策略稳健性的最终考验。

这个计划为你铺设了一条从入门到精通的清晰路径。**从现在开始，创建你的项目，完成阶段一的第一步：定义核心数据结构。** 每一步的成功都会为你迈向下一步提供巨大的信心。祝你编码愉快！